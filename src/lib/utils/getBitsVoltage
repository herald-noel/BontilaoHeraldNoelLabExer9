import { VoltageType } from "../../types/VoltageType";
import { EncodingType } from "../../types/EncodingType";

export default function getBitsVoltage(
  bits: string[],
  encodingType: EncodingType
) {
  const voltages: Array<VoltageType> = [];

  switch (encodingType) {
    case EncodingType.Nrzl:
      bits.forEach((element) => {
        element === "1"
          ? voltages.push(VoltageType.High)
          : voltages.push(VoltageType.Low);
      });

    case EncodingType.Nrzi:
      let previousVoltage = VoltageType.Low;
      bits.forEach((element) => {
        if (element === "1") {
          if (previousVoltage === VoltageType.Low) {
            voltages.push(VoltageType.High);
            previousVoltage = VoltageType.High;
          } else {
            voltages.push(VoltageType.Low);
            previousVoltage = VoltageType.Low;
          }
        } else {
          voltages.push(previousVoltage);
        }
      });

    case EncodingType.BipolarAMI:
      let previousBinaryOne = VoltageType.Low;
      bits.forEach((element) => {
        element === "1"
          ? previousBinaryOne === VoltageType.Low
            ? voltages.push(VoltageType.High)
            : voltages.push(VoltageType.Low)
          : voltages.push(VoltageType.Zero);
      });

    case EncodingType.Pseudoternary:
      let previousBinaryZero = VoltageType.Low;
      bits.forEach((element) => {
        element === "0"
          ? previousBinaryZero === VoltageType.Low
            ? voltages.push(VoltageType.High)
            : voltages.push(VoltageType.Low)
          : voltages.push(VoltageType.Zero);
      });

    case EncodingType.Manchester:
      bits.forEach((element) => {
        element === "1"
          ? voltages.push(VoltageType.LowToHigh)
          : voltages.push(VoltageType.HighToLow);
      });
  }
}
